///////////////////////////////////////////////////////////////////////////////
//
// Revolution external main entry point for 'arrayExample'
//
// Generated by External Creator V1.00
//
// For language: C++
//

#include <string>
#include <memory>

#include <revolution/external.h>

#include "utility.h"
#include "variable.h"

#include "string.h"

// **Mark Waddingham of Runtime Revolution** 
// externals are loaded when stack using it loads and stay persistent in memory
// until Rev quits so can put data into memory controlled by
// external and access it later
// need to declare the variable to hold the data outside each function so has correct scope and is persistent
// below is a line written by Mark Waddingham of Rev at RevCon Live 2008
//
// double *s_my_array = NULL;
//

// but use this
// only 3 components now but declare the [0] row so can use index 1 for component 1, etc.
double Fluid [4] [201];
double Solid [4] [201];


///////////////////////////////////////////////////////////////////////////////
//
// BEGIN USER DEFINITIONS

// **Mark Waddinghom of Runtime Revolution** 
// says that can not return an array as a function result
// so need to return an array through one of the input arguments
// in Rev need to create the output array but don't need to assign array values
// e.g., just put empty into myOutputArray

// !!! ALSO MUST ADD NEW FUNCTIONS TO LIST OF EXTERNALS DECLARED AT BOTTOM OF THIS FILE !!!

void oxidationInit(char *p_arguments[], int p_argument_count, char **r_result, Bool *r_pass, Bool *r_error)
{

	// 'oxidationInit' takes 2 parameters, two arrays specifying initial conditions for Fluid and Solid

	// Check to see if we have the right number of parameters.
	//
	if (p_argument_count != 2)
		throw ErrorException("illegal number of things you are inputing!!!");
		
	// construct Variable structures using pointers to input Rev arrays

	Variable t_fluid(p_arguments[0]);
	Variable t_solid(p_arguments[1]);

	int c;
	int n;
	char t_key[16];
		
	for (c=0; c < 4; c++)
	{
		for (n=0; n < 201; n++)
		{
			sprintf(t_key, "%d,%d", c, n);	
		    Fluid [c] [n] = t_fluid . GetRealElement(t_key);
			Solid [c] [n] = t_solid . GetRealElement(t_key);
		}
	}

/*	
	// as test, send result back to Rev
	for (c=0; c < 4; c++)
	{
		for (n=0; n < 201; n++)
		{
			// convert integer indexes to strings to match rev array keys, e.g., to "12,20"
			// can't have blanks in "" unless they are in rev keys
			sprintf(t_key, "%d,%d", c, n);	
			t_fluid . SetRealElement(t_key,Fluid[c][n]);
			t_solid . SetRealElement(t_key,Solid[c][n]);
		}
	}
*/

/*
	// change one element to test external
	Fluid[1][1] = 0.000101;
	c = 1;
	n = 1;
	sprintf(t_key, "%d,%d", c, n);	
	t_fluid . SetRealElement(t_key,Fluid[c][n]);
*/
	
	// XXXXXXXX NEED THIS AT VERY END OF FUNCTION DEF XXXXXXX
	// If we got to here it means there were no errors
	//
	*r_pass = False;
	*r_error = False;
	*r_result = strdup("");
		
}

void oxidationStep(char *p_arguments[], int p_argument_count, char **r_result, Bool *r_pass, Bool *r_error)
{
	// 'oxidationStep' take 4 parameters, 
	// one [4] input array for Cin,
	// one [4][10] input array for params, and element [0][2] for time step dt is changed here, adaptive time stepping
	// and two [4][100] output arrays, it uses persistant arrays created by oxidationInit

	// Check to see if we have the right number of parameters.
	//
	if (p_argument_count != 4)
		throw ErrorException("illegal number of things you are inputing!!!");
		
	// construct Variable structures using pointers to input Rev arrays

	Variable t_Cin(p_arguments[0]);
	Variable t_param(p_arguments[1]);
	
	// construct Variable structure for output arrays
	
	Variable t_fluid(p_arguments[2]);
	Variable t_solid(p_arguments[3]);	

	// don't use Cin[0], Cin[1] for comp 1 so can use c=1 for comp 1, etc.
	double Cin [4];
	double newFluid [4] [201];
	double newSolid [4] [201];
	
	// p[0][n] is used for general params
	double p [4] [21];
	
	char t_key[16];
	int n;
	int c;
	int r;
	
	// new variables 
	double tMaxK;
	double dFdt [4];
	double dSdt [4];
	double ofac = 2.0; // inverse of max Oads coverage allowed
	double sVacO2; // vacancy for O2 adsorption
	int tNm1;
	int ncomp;
	int nrepeats;

// ----- BEGIN USE FOR WINDOWS ONLY -----

	// // WAS USED FOR WIN ONLY WHEN PROBLEMS WITH SetRealElement & signif figs
	// // used at bottom when returning final values to Rev
	// char cFtemp[16];
	// char cStemp[16];

	// // FOR WIN - OPTIONAL FOR MAC
	// // had problems with NaN in values to be returned to Rev on Win
	for (c=0; c < 4; c++)
	{
		for (n=0; n < 201; n++)
		{
			newFluid[c][n] = 0.0;
			newSolid[c][n] = 0.0;
		}
	}
	
//	----- END FOR WINDOWS ONLY -------
//
	
	for (c=0; c < 4; c++)
	{
		for (n=0; n < 10; n++)
		{
			sprintf(t_key, "%d,%d", c, n);	
		    p [c] [n] = t_param . GetRealElement(t_key);
		}
	}
	
	// -- p[0,n] vector contains common parameter values
    // put spaceVeloc into p[0,0] -- (1/s), Q/Vcell, space velocity, fluid volumes swept per unit time
    // put km*Vratio/L into p[0,1] -- (1/s), (km * Vpellet)/(Vcell * L), km (m/s) is mass transfer coefficient, same for all components here
    // put dt into p[0,2] -- just an initial value because now changed in stepTheSim
    // put nnodes into p[0,3]
    // put 50 into p[0,4] -- number of time steps within stepTheSim
    // put 15 into p[0,5] -- percent change per step for calc of dt in stepTheSim
    // put ncomp into p[0,6]

	ncomp = p[0][6];
	nrepeats = p[0][4];

	for (c=0; c < ncomp+1; c++)
	{
		sprintf(t_key, "%d", c);
		Cin [c] = t_Cin . GetRealElement(t_key);
	}

	//  now do calcs with p array and with Fluid and Solid to form newFluid and newSolid

	// -- find largest rate constant so can take appropriate time step
	
    // put p[0,0] into tMaxK
	tMaxK = p[0][0];
	
	// only check the p's with rate constants, DOES NOT MAKE SENSE TO SCAN ALL P'S E.G., P[0][3] IS NNODES!
	if (p[0][1] > tMaxK) tMaxK = p[0][1];
	 
    // repeat with c = 0 to ncomp
	for (c=1; c < ncomp+1; c++)
	{
        // repeat with n = 0 to 6
		for (n=0; n < 6; n++)
		{
            // if p[c,n] > tMaxK then put p[c,n] into tMaxK
			if (p[c][n] > tMaxK) tMaxK = p[c][n];
		}
	}
	
	// -- approximate d(var)/dt = tMaxK * (var)
    // -- want d(var) = tMaxK * (var) * dt = (var)*p[0,5]/100 for p[0,5]% change in current value of (var) per time step
    // -- so set dt = p[0,5]/(100 * tMaxK)
	
	// NOTE P[0][2] GETS MODIFIED SO NEEDS TO BE RETURNED TO REV FOR PLOTTING
	// EITHER RETURN P ARRAY OR RETURN SEPARATELY
	
    // put p[0,5]/(100*tMaxK) into p[0,2]
	p[0][2] = p[0][5]/(100.0 * tMaxK);
	
    // put p[0,3]-1 into tNm1 -- number of next to last node, cut down on computing this below
	tNm1 = p[0][3] - 1;
     
    // repeat p[0,4] times
	for (r=0; r < nrepeats; r++)
	{
	
		// -- need to put new values into newPellet before updating any values in Pellet
		
        // -- do the fluid in cell with flow and mass transfer
        // -- inlet conc is Cin[c]
        // -- fluid conc in cell is Fluid[c,0]
        // -- fluid conc in pellet at pellet-cell boundary is Fluid[c,1]
		
		// repeat with c = 1 to nComp
		for (c=1; c < ncomp+1; c++)
		{
			
           // put p[0,0]*(Cin[c] - Fluid[c,0]) - p[0,1]*(Fluid[c,0] - Fluid[c,1]) into dFdt[c]
		   dFdt[c] = p[0][0]*(Cin[c] - Fluid[c][0]) - p[0][1]*(Fluid[c][0] - Fluid[c][1]);
			
			// put Fluid[c,0] + dFdt[c] * p[0,2] into newFluid[c,0]
			newFluid[c][0] = Fluid[c][0] + dFdt[c] * p[0][2];
			
			// if newFluid[c,0] < 0 then put 0.0 into newFluid[c,0]
			if (newFluid[c][0] < 0.0) newFluid[c][0] = 0.0;
			
        // end repeat
		}
		
		// -- do node 1 separately because of boundary with cell
        // -- node 0 is fluid in cell (undefined for surface conc)
        // -- node 1 is at outer surface plane of porous layer
        // -- node nnodes is at zero-flux plane of porous layer
         
	   // put 1 into n
	   n = 1;
	   
        // repeat with c = 1 to nComp
		for (c=1; c < ncomp+1; c++)
		{
             
			// -- xxx try setting Fluid[c,1] so that flux on both side of cell-pellet boundary match 
			// -- XXX ( for now, ignore reaction and transient at this node)
			// put p[c,7]*Fluid[c,0] + p[c,8]*Fluid[c,2] into newFluid[c,1]
			newFluid[c][1] = p[c][7]*Fluid[c][0] + p[c][8]*Fluid[c][2];
						
			// if newFluid[c,1] < 0 then put 0.0 into newFluid[c,1]
			if (newFluid[c][1] < 0.0) newFluid[c][1] = 0.0;
            
            // -- new surface reaction: - p[3,5]*Solid[1,n]*Solid[2,n]
            // -- now comp 2 is like dissociative adsorption of O2 to O ads
            // if c = 1 then
			if (c == 1)
			
                //  p[c,3]*Fluid[c,n]*(1.0 - Solid[1][n]-Solid[2][n]) - p[c,4]*Solid[c,n]  - p[3,6]*Solid[1,n]*Solid[2,n] into dSdt[c]
				dSdt[c] = p[c][3]*Fluid[c][n]*(1.0 - Solid[1][n]-Solid[2][n]) - p[c][4]*Solid[c][n]  - p[3][6]*Solid[1][n]*Solid[2][n];
				
            // else if c = 2 then -- dissociative ads, note 2*p[c,3], each ads/des event consumes/creates 1 fluid O2 but 2 surface 0ads
			else if (c == 2)
			{
                // put 2*p[c,3]*Fluid[c,n]*(1.0 - Solid[1][n]-Solid[2][n])^2 - 2*p[c,4]*Solid[c,n]^2  - p[3,6]*Solid[1,n]*Solid[2,n] into dSdt[c]
				sVacO2 = (1.0-Solid[1][n]-ofac*Solid[2][n]);
				if (sVacO2 < 0.0) sVacO2 = 0.0;
				if (sVacO2 > 1.0) sVacO2 = 1.0;
				dSdt[c] = 2.0*p[c][3]*Fluid[c][n]*sVacO2*sVacO2 - 2.0*p[c][4]*Solid[c][n]*Solid[c][n] - p[3][6]*Solid[1][n]*Solid[2][n];
			}
             
            // if c < 3 then -- no solid conc for comp 3 (CO2)
			if (c < 3)
			{
				// put Solid[c,n] + dSdt[c] * p[0,2] into newSolid[c,n]
				newSolid[c][n] = Solid[c][n] + dSdt[c] * p[0][2];
			   
				// if newSolid[c,n] < 0 then put 0.0 into newSolid[c,n]
				if (newSolid[c][n] < 0.0) newSolid[c][n] = 0.0;
					
                // if newSolid[c,n] > 1 then put 1.0 into newSolid[c,n]
				if (newSolid[c][n] > 1.0) newSolid[c][n] = 1.0;
					
			// end if
			}
			
		// end repeat
		}
						
		// -- now do the internal nodes, the rest of nodes except last one
         
        // repeat with c = 1 to 2 << but change to all comp here, change from orig rev	
		for (c=1; c < ncomp+1; c++)
		{
            // repeat with n = 2 to tNm1
			for (n=2; n < tNm1+1; n++)
			{
                 
                // -- now comp 2 is like dissociative adsorption of O2 to O ads
				
                // if c = 1 then
				if (c == 1)
				
                    // put p[c,0]*(Fluid[c,n+1]+Fluid[c,n-1]-2*Fluid[c,n]) - p[c,1]*Fluid[c,n]*(1.0 - Solid[1][n]-Solid[2][n]) + p[c,2]*Solid[c,n] into dFdt[c]
					dFdt[c] = p[c][0]*(Fluid[c][n+1]+Fluid[c][n-1]-2.0*Fluid[c][n]) - p[c][1]*Fluid[c][n]*(1.0 - Solid[1][n]-Solid[2][n]) + p[c][2]*Solid[c][n];
					
				// else if c = 2 then
				else if (c == 2)
				{
                    // put p[c,0]*(Fluid[c,n+1]+Fluid[c,n-1]-2*Fluid[c,n]) - p[c,1]*Fluid[c,n]*(1.0 - Solid[1][n]-Solid[2][n])^2 + p[c,2]*Solid[c,n]^2 into dFdt[c]
					sVacO2 = (1.0-Solid[1][n]-ofac*Solid[2][n]);
					if (sVacO2 < 0.0) sVacO2 = 0.0;
					if (sVacO2 > 1.0) sVacO2 = 1.0;
					dFdt[c] = p[c][0]*(Fluid[c][n+1]+Fluid[c][n-1]-2.0*Fluid[c][n]) - p[c][1]*Fluid[c][n]*sVacO2*sVacO2 + p[c][2]*Solid[c][n]*Solid[c][n];
				}
				else if (c == 3)
					
					// component 3 here is CO2 with only diffusion and production by surface reaction
 					dFdt[c] = p[c][0]*(Fluid[c][n+1]+Fluid[c][n-1]-2.0*Fluid[c][n]) + p[c][5]*Solid[1][n]*Solid[2][n];

				// end if
                
                // -- new surface reaction: - p[3,5]*Solid[1,n]*Solid[2,n]
                // -- now comp 2 is like dissociative adsorption of O2 to O ads
				
                // if c = 1 then
				if (c == 1)
				
                    // put p[c,3]*Fluid[c,n]*(1.0 - Solid[1][n]-Solid[2][n]) - p[c,4]*Solid[c,n] - p[3,6]*Solid[1,n]*Solid[2,n] into dSdt[c]
					dSdt[c] =  p[c][3]*Fluid[c][n]*(1.0 - Solid[1][n]-Solid[2][n]) - p[c][4]*Solid[c][n] - p[3][6]*Solid[1][n]*Solid[2][n];
					
                // else if c = 2 then -- dissociative ads, note 2*p[c,3], each ads/des event consumes/creates 1 fluid O2 but 2 surface 0ads
				else if (c == 2)
				{
                    // put 2*p[c,3]*Fluid[c,n]*(1.0 - Solid[1][n]-Solid[2][n])^2 - 2*p[c,4]*Solid[c,n]^2  - p[3,6]*Solid[1,n]*Solid[2,n] into dSdt[c]
					sVacO2 = (1.0-Solid[1][n]-ofac*Solid[2][n]);
					if (sVacO2 < 0.0) sVacO2 = 0.0;
					if (sVacO2 > 1.0) sVacO2 = 1.0;
					dSdt[c] = 2.0*p[c][3]*Fluid[c][n]*sVacO2*sVacO2 - 2.0*p[c][4]*Solid[c][n]*Solid[c][n]  - p[3][6]*Solid[1][n]*Solid[2][n];
				}
                 
               //  put Fluid[c,n] + dFdt[c] * p[0,2] into newFluid[c,n]
			   newFluid[c][n] = Fluid[c][n] + dFdt[c] * p[0][2];
			   
                // if newFluid[c,n] < 0 then put 0.0 into newFluid[c,n]
				if (newFluid[c][n] < 0.0) newFluid[c][n] = 0.0;
                 
                if (c < 3)
				{
				// no solid conc for component 3 here

				// put Solid[c,n] + dSdt[c] * p[0,2] into newSolid[c,n]
				newSolid[c][n] = Solid[c][n] + dSdt[c] * p[0][2];
				
                // if newSolid[c,n] < 0 then put 0.0 into newSolid[c,n]
				if (newSolid[c][n] < 0.0) newSolid[c][n] = 0.0;
				
                // if newSolid[c,n] > 1 then put 1.0 into newSolid[c,n] 
				if (newSolid[c][n] > 1.0) newSolid[c][n] = 1.0;
				}
                 
            // end repeat
			}
			
        // end repeat
		}
		
		
       // -- now do the last node at zero-flux plane of porous layer
         
        // repeat with c = 1 to 2
		for (c=1; c < 3; c++)
		{
             
            // -- now comp 2 is like dissociative adsorption of O2 to O ads
			
            // put p[0,3] into n
			n = p[0][3];
			
            // if c = 1 then
			if (c == 1)
			
                // put p[c,0]*(2*Fluid[c,n-1]-2*Fluid[c,n]) - p[c,1]*Fluid[c,n]*fSolidVac(n)+ p[c,2]*Solid[c,n] into dFdt[c]
				dFdt[c] = p[c][0]*(2*Fluid[c][n-1]-2*Fluid[c][n]) - p[c][1]*Fluid[c][n]*(1.0-Solid[1][n]-Solid[2][n])+ p[c][2]*Solid[c][n];
				
            // else if c = 2 then -- dissociative ads, note 2*p[c,3]
			else if (c == 2)
			{
                // put 2*p[c,3]*Fluid[c,n]*fSolidVac(n)^2 - 2*p[c,4]*Solid[c,n]^2  - p[3,6]*Solid[1,n]*Solid[2,n] into dSdt[c]
				sVacO2 = (1.0-Solid[1][n]-ofac*Solid[2][n]);
				if (sVacO2 < 0.0) sVacO2 = 0.0;
				if (sVacO2 > 1.0) sVacO2 = 1.0;
				dSdt[c] = 2.0*p[c][3]*Fluid[c][n]*sVacO2*sVacO2 - 2.0*p[c][4]*Solid[c][n]*Solid[c][n]  - p[3][6]*Solid[1][n]*Solid[2][n];
			}
             
            // -- new surface reaction:  - p[3,5]*Solid[1,n]*Solid[2,n]
            // -- now comp 2 is like dissociative adsorption of O2 to O ads
			
            // if c = 1 then
			if (c == 1)
			
                // put p[c,3]*Fluid[c,n]*fSolidVac(n) - p[c,4]*Solid[c,n]  - p[3,6]*Solid[1,n]*Solid[2,n] into dSdt[c]
				dSdt[c] = p[c][3]*Fluid[c][n]*(1.0-Solid[1][n]-Solid[2][n]) - p[c][4]*Solid[c][n]  - p[3][6]*Solid[1][n]*Solid[2][n];
				
            // else if c = 2 then -- dissociative ads, note 2*p[c,3], each ads/des event consumes/creates 1 fluid O2 but 2 surface 0ads
			else if (c == 2)
			{
                // put 2*p[c,3]*Fluid[c,n]*fSolidVac(n)^2 - 2*p[c,4]*Solid[c,n]^2  - p[3,6]*Solid[1,n]*Solid[2,n] into dSdt[c]
				sVacO2 = (1.0-Solid[1][n]-ofac*Solid[2][n]);
				if (sVacO2 < 0.0) sVacO2 = 0.0;
				if (sVacO2 > 1.0) sVacO2 = 1.0;
				dSdt[c] = 2.0*p[c][3]*Fluid[c][n]*sVacO2*sVacO2 - 2.0*p[c][4]*Solid[c][n]*Solid[c][n] - p[3][6]*Solid[1][n]*Solid[2][n];
			}
            	
            // put Fluid[c,n] + dFdt[c] * p[0,2] into newFluid[c,n]
			newFluid[c][n] = Fluid[c][n] + dFdt[c] * p[0][2];
			
            // if newFluid[c,n] < 0 then put 0.0 into newFluid[c,n]
			if (newFluid[c][n] < 0.0) newFluid[c][n] = 0.0;
             
            // put Solid[c,n] + dSdt[c] * p[0,2] into newSolid[c,n]
			newSolid[c][n] = Solid[c][n] + dSdt[c] * p[0][2];
			
            // if newSolid[c,n] < 0 then put 0.0 into newSolid[c,n]
			if (newSolid[c][n] < 0.0) newSolid[c][n] = 0.0;
			
            // if newSolid[c,n] > 1 then put 1.0 into newSolid[c,n]
			if (newSolid[c][n] > 1.0) newSolid[c][n] = 1.0;
             
        // end repeat
		}

        // -- now do the reaction product at zero-flux plane
         
        // put 3 into c
		c = 3;
		
        // put p[0,3] into n
		n = p[0][3];
		
        // put p[c,0]*(2*Fluid[c,n-1]-2*Fluid[c,n]) + p[3,5]*Solid[1,n]*Solid[2,n] into dFdt[c]
		dFdt[c] = p[c][0]*(2.0*Fluid[c][n-1]-2.0*Fluid[c][n]) + p[3][5]*Solid[1][n]*Solid[2][n];
        	
        // put Fluid[c,n] + dFdt[c] * p[0,2] into newFluid[c,n]
		newFluid[c][n] = Fluid[c][n] + dFdt[c] * p[0][2];
		
        // if newFluid[c,n] < 0 then put 0.0 into newFluid[c,n]
		if (newFluid[c][n] < 0.0) newFluid[c][n] = 0.0;
		
        // -- now replace the old values with the new values after computing all nodes
		
        // repeat with c = 1 to nComp
		for (c=1; c < ncomp + 1; c++)
		{
            // repeat with n = 0 to p[0,3]
			for (n=0; n < p[0][3] + 1; n++)
			{
		
                // put newFluid[c,n] into Fluid[c,n]
				Fluid[c][n] = newFluid[c][n];
				
                // put newSolid[c,n] into Solid[c,n]
				Solid[c][n] = newSolid[c][n];
				
            // end repeat
			}
			
        // end repeat
		}
	
	// end repeat
	}
		
	// after all steps in time, copy final newFluid to persistent Fluid and newSolid to persistent Solid
	 
	for (c=1; c < ncomp + 1; c++)
	{
		for (n=0; n < tNm1 + 2; n++)
		{	
		    Fluid [c] [n] = newFluid [c] [n];
			Solid [c] [n] = newSolid [c] [n];
		}
	}
		
	// and then copy results to output Rev arrays t_fluid and t_solid
	
	for (c=1; c < ncomp + 1; c++)
	{
		for (n=0; n < tNm1 + 2; n++)
		{
			// convert integer indexes to strings to match rev array keys, e.g., to "12,20"
			// can't have blanks in "" unless they are in rev keys
			sprintf(t_key, "%d,%d", c, n);	
			
			// // FOR MAC ONLY
			t_fluid . SetRealElement(t_key,Fluid[c][n]);
			t_solid . SetRealElement(t_key,Solid[c][n]);

			// ABOVE NOW WORKS IN WINDOWS XP
			// SEE THESE CHANGES IN FILE VARIABLE.CPP
			//
			// XXX CHANGE PER MARK WADDINGHAM TO: #define DOUBLE_LENGTH (16 + 1 + 1 + 1 + 3 + 1)
			// XXX FROM: #define DOUBLE_LENGTH (15 + 1 + 1 + 1 + 3)

			// // FOR WINDOWS ONLY
			// // have problems with SetRealElement returning values with approx > 9 signif figs
			// // format "%.8e" returns 9 significant figs, e.g., 1.23456789e-001
			// sprintf(cFtemp,"%.8e",newFluid[c][n]);
			// sprintf(cStemp,"%.8e",newSolid[c][n]);
			// t_fluid . SetStringElement(t_key,cFtemp);
			// t_solid . SetStringElement(t_key,cStemp);

		}
	}
	
	// DO THIS BECAUSE P[0][2] GETS MODIFIED AND REV NEEDS FOR PLOTTING
	
	c = 0;
	n = 2;
	sprintf(t_key, "%d,%d", c, n);	
	t_param . SetRealElement(t_key,p[c][n]);
	
	// XXXXXXXX NEED THIS AT VERY END OF FUNCTION DEF XXXXXXX
	// If we got to here it means there were no errors
	//
	*r_pass = False;
	*r_error = False;
	*r_result = strdup("");

}

// END USER DEFINITIONS
//
///////////////////////////////////////////////////////////////////////////////


EXTERNAL_BEGIN_DECLARATIONS("arrayExample")

// BEGIN USER DECLARATIONS

EXTERNAL_DECLARE_COMMAND("oxidationInit", oxidationInit)
EXTERNAL_DECLARE_COMMAND("oxidationStep", oxidationStep)

// END USER DECLARATIONS

EXTERNAL_END_DECLARATIONS
